# 📝 Amelcraft: A Kid-Friendly 2D Minecraft-Inspired Game

## 🔄 Project Evolution
The project began as a birthday idea for a 7-year-old, inspired by the Minecraft hype but aiming for simplicity and accessibility. The concept evolved from a general 2D block-building game to a focused, responsive, cross-device experience using Phaser.js. Early discussions weighed complexity (e.g., day/night cycles, pathfinding) against the need for a fun, easy-to-play game. The design journey included debates about control schemes, building mechanics, and the choice between 2D and simulated 3D, ultimately favoring a top-down, grid-based approach for ease of use and development.

## 🚀 Project Genesis & Motivation
The motivation was personal: to create a custom game for a child’s birthday, capturing the excitement of Minecraft in a form approachable for a young beginner. The project was inspired by the child’s fascination with Minecraft and the desire to provide a creative, interactive experience tailored to her age and skills. The goal was to foster creativity, exploration, and fun, while keeping technical and gameplay complexity low.

## 🚀 Project Overview
Amelcraft is a simple, 2D, tile-based game where players can harvest materials and place blocks in a world reminiscent of Minecraft. Designed for both desktop and mobile, it features responsive controls and adaptive camera zoom, ensuring a smooth experience across devices. The game is intended for young children, with intuitive drag-to-move controls and straightforward block placement.

## 💡 Core Ideas & Features
- **2D Tile-Based World:** The game world is a grid of 48x48px tiles.
- **Harvesting & Placing Blocks:** Players collect materials and place blocks on the grid.
- **Drag-to-Move Controls:** Movement is controlled by dragging on the screen (touch or mouse).
- **Responsive Design:** The game adapts to device size and orientation, with dynamic camera zoom.
- **Simple Inventory:** Materials collected are stored and can be selected for placement.
- **Single-File POC:** Initial proof-of-concept provided as a single HTML file for easy testing.

## 🧩 Design Decisions & Rationale
- **Phaser.js Chosen:** For rapid development and cross-platform support.
- **Drag-to-Move Over Click-to-Move:** Simpler for young children, avoids pathfinding complexity.
- **Top-Down (Horizontal) Building:** More intuitive for kids, easier to implement than vertical or 3D.
- **Responsive Canvas & Camera Zoom:** Ensures playability on all devices, keeps sprites visible and detailed.
- **No Day/Night Cycle:** Dropped for simplicity.
- **Block Placement Logic:** Grid-based, with pointer-to-tile conversion for intuitive interaction.

## ❌ Rejected Ideas & Alternatives
- **Day/Night Cycle:** Rejected to keep the game simple.
- **Click-to-Move with Pathfinding:** Considered but dropped due to complexity.
- **3D or Isometric Building:** Rejected for technical and cognitive simplicity; 2D chosen.
- **Vertical (Wall) Building:** Considered, but horizontal (ground) building selected for accessibility.

## ⚖️ Player vs. Team Focus Debate
The game is designed as a single-player experience, focused on individual creativity and exploration. Team or multiplayer features were not prioritized, given the target audience and scope.

## 🌏 Personal/Inspirational Details
The project was inspired by a child’s birthday and her fascination with Minecraft. The design choices reflect a desire to create a fun, approachable experience tailored to her interests and abilities.

## 💬 Key Conversation Excerpts
> “For my daughter's 7th birthday I want to make her a little video game, using phaser.js...simple 2D, sprite and tilemap based game, in which she can harvest a few materials and then place blocks from these materials in the world.”

> “I want the game to run on a desktop, as well as a mobile phone...controllable by touch/mouse click and the game screen and camera zoom level should adapt itself to the device.”

> “For simplicity and a smooth experience for a 7-year-old, Option 2 (drag-to-move) is best. It’s easy to implement in Phaser, and kids enjoy direct control.”

> “For a Minecraft-like experience and simplicity for a child, the horizontal plane (top-down) is best. It’s intuitive, easy to control, and lets your daughter ‘walk’ over her creations.”

## 🏗️ Architecture & Structure
- **Phaser.js Engine:** Handles rendering, input, and game logic.
- **Responsive Canvas:** Uses Phaser’s scale manager for device adaptation.
- **Camera Zoom Logic:** Dynamically calculates zoom based on screen size and tile size.
- **Player Sprite:** Controlled via drag-to-move pointer events.
- **Tile Grid:** 2D array represents the world; block placement updates the grid and renders sprites.
- **Inventory System:** Simple array for collected materials and block selection.

## 💻 Code Snippets & Examples

### Responsive Game Screen

<CodePlayground
  template="vanilla"
  files={{
    'index.html': `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Responsive Phaser POC</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    html, body {
      height: 100%;
      margin: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      background: #222;
    }
    #game-container { width: 100vw; height: 100vh; }
  </style>
</head>
<body style="margin: 0; padding: 0;">
  <div id="game-container"></div>
  <script src="index.js"></script>
</body>
</html>
    `,
    'index.js': `
// Dynamically load Phaser, then run the game code
function loadPhaserAndRun(main) {
  if (window.Phaser) return main();
  var script = document.createElement('script');
  script.src = 'https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js';
  script.onload = main;
  document.head.appendChild(script);
}

loadPhaserAndRun(function() {
  const tileSize = 48;
  const maxWidth = 1280;
  const maxHeight = 800;

  function getResponsiveConfig() {
    const width = Math.min(window.innerWidth, maxWidth);
    const height = Math.min(window.innerHeight, maxHeight);
    return { width, height };
  }

  const { width, height } = getResponsiveConfig();

  const config = {
    type: Phaser.AUTO,
    parent: 'game-container',
    width,
    height,
    backgroundColor: '#333',
    scale: {
      mode: Phaser.Scale.FIT,
      autoCenter: Phaser.Scale.CENTER_BOTH,
    },
    scene: {
      preload,
      create,
      update
    },
    physics: {
      default: 'arcade',
      arcade: { debug: false }
    }
  };

  let player;
  let cursors;
  let camera;

  function preload() {
    // Placeholder: load a simple square as player
    this.textures.generate('player', { data: ['3'], pixelWidth: tileSize });
  }

  function create() {
    // Add player sprite in center
    player = this.physics.add.sprite(width/2, height/2, 'player');
    player.setDisplaySize(tileSize, tileSize);
    player.setCollideWorldBounds(true);

    camera = this.cameras.main;
    camera.startFollow(player, true, 0.1, 0.1);

    // Responsive camera zoom
    let desiredTiles = Math.max(8, Math.min(Math.floor(width / tileSize), 16));
    let zoom = width / (tileSize * desiredTiles);
    camera.setZoom(zoom);

    // Handle window resize
    window.addEventListener('resize', () => {
      const { width: newWidth, height: newHeight } = getResponsiveConfig();
      this.scale.resize(newWidth, newHeight);
      // Recalculate zoom
      desiredTiles = Math.max(8, Math.min(Math.floor(newWidth / tileSize), 16));
      zoom = newWidth / (tileSize * desiredTiles);
      camera.setZoom(zoom);
    });
  }

  function update() {
    // No movement logic yet
  }

  new Phaser.Game(config);
});
`
}}/>

### Drag to Move

<CodePlayground
  template="vanilla"
  files={{
    'index.html': `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Drag to Move Example - Phaser</title>
    <style>
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        background: #222;
        overflow: hidden;
      }
      #game-container {
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body style="margin: 0; padding: 0;">
    <div id="game-container"></div>
    <script src="index.js"></script>
  </body>
</html>
`,
    'index.js': `
// Dynamically load Phaser, then run the game code
function loadPhaserAndRun(main) {
  if (window.Phaser) return main();
  var script = document.createElement('script');
  script.src = 'https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js';
  script.onload = main;
  document.head.appendChild(script);
}

loadPhaserAndRun(function() {
  let player;
  let isDragging = false;
  let target = null;
  const moveSpeed = 1; // px per frame

  function preload() {
    this.load.image(
      "player",
      "https://labs.phaser.io/assets/sprites/phaser-dude.png"
    );
  }

  function create() {
    player = this.add.sprite(this.sys.game.config.width/2, this.sys.game.config.height/2, "player").setScale(2);

    // Use the canvas element for pointer events for better reliability
    const canvas = this.sys.game.canvas;
    let pointerMoveHandler = null;
    let pointerUpHandler = null;

    canvas.addEventListener("pointerdown", (e) => {
      isDragging = true;
      target = { x: e.offsetX, y: e.offsetY };

      pointerMoveHandler = (ev) => {
        if (isDragging) {
          target = { x: ev.offsetX, y: ev.offsetY };
        }
      };
      canvas.addEventListener("pointermove", pointerMoveHandler);

      pointerUpHandler = () => {
        isDragging = false;
        target = null;
        canvas.removeEventListener("pointermove", pointerMoveHandler);
        canvas.removeEventListener("pointerup", pointerUpHandler);
      };
      canvas.addEventListener("pointerup", pointerUpHandler);
    });
  }

  function update() {
    if (isDragging && target) {
      const dx = target.x - player.x;
      const dy = target.y - player.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist > moveSpeed) {
        player.x += (dx/dist) * moveSpeed;
        player.y += (dy/dist) * moveSpeed;
      } else {
        player.x = target.x;
        player.y = target.y;
      }
    }
  }

  const config = {
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight,
    backgroundColor: "#87ceeb",
    parent: "game-container",
    scene: {
      preload,
      create,
      update,
    },
  };

  new Phaser.Game(config);
});
`
  }}
/>

### Block Placement

<CodePlayground
  template="vanilla"
  files={{
    'index.html': `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Block Placement Example - Phaser</title>
    <style>
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        background: #222;
        overflow: hidden;
      }
      #game-container {
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body style="margin: 0; padding: 0;">
    <div id="game-container"></div>
    <script src="index.js"></script>
  </body>
</html>
`,
    'index.js': `
// Dynamically load Phaser, then run the game code
function loadPhaserAndRun(main) {
  if (window.Phaser) return main();
  var script = document.createElement('script');
  script.src = 'https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js';
  script.onload = main;
  document.head.appendChild(script);
}

loadPhaserAndRun(function() {
  const tileSize = 48;
  const gridWidth = 10;
  const gridHeight = 8;
  let worldTiles = Array.from({length: gridWidth}, () => Array(gridHeight).fill(0));

  function preload() {
    this.load.image('block', 'https://labs.phaser.io/assets/sprites/block.png');
  }

  function create() {

    this.input.on('pointerdown', (pointer) => {
      const tileX = Math.floor(pointer.worldX / tileSize);
      const tileY = Math.floor(pointer.worldY / tileSize);
      if (tileX >= 0 && tileX < gridWidth && tileY >= 0 && tileY < gridHeight && worldTiles[tileX][tileY] === 0) {
        worldTiles[tileX][tileY] = 1;
        // Add a block sprite that fills the tile (48x48)
        const block = this.add.sprite(
          tileX * tileSize + tileSize/2,
          tileY * tileSize + tileSize/2,
          'block'
        );
        block.displayWidth = tileSize;
        block.displayHeight = tileSize;
      }
    });
    // Draw grid lines for clarity
    for (let x = 0; x <= gridWidth; x++) {
      this.add.line(0, 0, x*tileSize, 0, x*tileSize, gridHeight*tileSize, 0x888888).setOrigin(0);
    }
    for (let y = 0; y <= gridHeight; y++) {
      this.add.line(0, 0, 0, y*tileSize, gridWidth*tileSize, y*tileSize, 0x888888).setOrigin(0);
    }
  }

  const config = {
    type: Phaser.AUTO,
    width: tileSize * gridWidth,
    height: tileSize * gridHeight,
    backgroundColor: '#bada55',
    parent: 'game-container',
    scene: {
      preload,
      create
    }
  };

  new Phaser.Game(config);
});
`
  }}
/>

## 📚 References & Inspirations
- [Phaser.js Documentation](https://phaser.io/)
- Minecraft (as inspiration for block-building mechanics)
- Stardew Valley, Zelda (for top-down design ideas)

## ❓ Open Questions & Next Steps
- Expand inventory and block types.
- Add harvesting mechanics and sound effects.
- Design custom sprites and tiles.
- Consider simple NPCs or animals for added fun.
- Polish UI for block selection and inventory management.
